
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { Sparkles, Loader2 } from 'lucide-react';
import { InvestorDoc, DocSection } from '../../types';
import { useData } from '../../context/DataContext';
import { API_KEY } from '../../lib/env';
import { useToast } from '../../context/ToastContext';
import { DocumentAI } from '../../services/documentAI';

import { EditorToolbar } from './editor/EditorToolbar';
import { SectionList } from './editor/SectionList';
import { EditorSidebar } from './editor/EditorSidebar';

// Workaround for strict type checking
const MotionDiv = motion.div as any;

interface DocumentEditorProps {
  doc: InvestorDoc;
  onBack: () => void;
}

export const DocumentEditor: React.FC<DocumentEditorProps> = ({ doc, onBack }) => {
  const { profile, updateDoc } = useData();
  const { success, error: toastError, info } = useToast();
  
  const [isGenerating, setIsGenerating] = useState(false);
  const [refiningAction, setRefiningAction] = useState<string | null>(null);
  const [activeSectionId, setActiveSectionId] = useState<string>('1');
  const [saveStatus, setSaveStatus] = useState<'saved' | 'saving'>('saved');

  // Local state for immediate editing
  const [title, setTitle] = useState(doc.title);
  const [sections, setSections] = useState<DocSection[]>(
    doc.content.sections.length > 0 ? doc.content.sections : [
      { id: '1', title: 'Introduction', content: '<p>Start typing...</p>' }
    ]
  );

  // Debounced Save
  useEffect(() => {
      const hasChanged = title !== doc.title || JSON.stringify(sections) !== JSON.stringify(doc.content.sections);
      
      if (hasChanged) {
          setSaveStatus('saving');
          const timer = setTimeout(() => {
              updateDoc(doc.id, { 
                  title, 
                  content: { sections } 
              });
              setSaveStatus('saved');
          }, 1000);
          return () => clearTimeout(timer);
      }
  }, [title, sections, doc.id, doc.title, doc.content.sections, updateDoc]);

  // --- AI ACTIONS ---

  const handleGenerateDraft = async () => {
    if (!profile) {
        toastError("No startup profile found. Please complete onboarding.");
        return;
    }
    if (!API_KEY) {
        toastError("API Key missing");
        return;
    }

    setIsGenerating(true);

    try {
        const profileContext = {
            name: profile.name,
            tagline: profile.tagline,
            mission: profile.mission,
            problem: profile.problemStatement,
            solution: profile.solutionStatement,
            targetMarket: profile.targetMarket,
            businessModel: profile.businessModel
        };

        const newSections = await DocumentAI.generateDraft(API_KEY, doc.type, profileContext);
        
        if (newSections) {
            setSections(newSections);
            setActiveSectionId(newSections[0]?.id || '1');
            success("Document draft generated!");
        }
    } catch (error) {
        toastError("Failed to generate document.");
    } finally {
        setIsGenerating(false);
    }
  };

  const handleRefine = async (action: 'clearer' | 'expand' | 'shorten' | 'grammar') => {
      if (!API_KEY) {
          toastError("API Key missing");
          return;
      }

      const activeSection = sections.find(s => s.id === activeSectionId);
      if (!activeSection) return;

      setRefiningAction(action);
      info("Refining section with AI...");

      try {
          const refinedContent = await DocumentAI.refineSection(API_KEY, activeSection.content, action);
          if (refinedContent) {
              setSections(prev => prev.map(s => s.id === activeSectionId ? { ...s, content: refinedContent } : s));
              success("Section updated!");
          }
      } catch (e) {
          toastError("Failed to refine section.");
      } finally {
          setRefiningAction(null);
      }
  }

  const handleExport = () => {
      const docContent = `
        <html>
          <head><title>${title}</title></head>
          <body style="font-family: sans-serif; padding: 40px; max-width: 800px; margin: 0 auto;">
            <h1 style="color: #333; border-bottom: 2px solid #eee; padding-bottom: 10px;">${title}</h1>
            <p style="color: #666; font-size: 14px;">Generated by StartupAI for ${profile?.name}</p>
            ${sections.map(s => `
                <div style="margin-bottom: 30px;">
                    <h2 style="color: #4f46e5;">${s.title}</h2>
                    <div>${s.content}</div>
                </div>
            `).join('')}
          </body>
        </html>
      `;
      
      const blob = new Blob([docContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${title.replace(/\s+/g, '_')}.html`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      success("Exported to HTML");
  }

  const updateSectionContent = (id: string, newContent: string) => {
      setSections(prev => prev.map(s => s.id === id ? { ...s, content: newContent } : s));
  }

  const updateSectionTitle = (id: string, newTitle: string) => {
      setSections(prev => prev.map(s => s.id === id ? { ...s, title: newTitle } : s));
  }

  return (
    <MotionDiv 
      initial={{ opacity: 0, x: 20 }}
      animate={{ opacity: 1, x: 0 }}
      exit={{ opacity: 0, x: 20 }}
      transition={{ duration: 0.3 }}
      className="flex flex-col h-full"
    >
      <EditorToolbar 
        title={title}
        status={doc.status}
        type={doc.type}
        saveStatus={saveStatus}
        onTitleChange={setTitle}
        onBack={onBack}
        onExport={handleExport}
      />

      <div className="flex-1 flex overflow-hidden">
         
         <SectionList 
            sections={sections}
            activeSectionId={activeSectionId}
            onSelect={setActiveSectionId}
            onAddSection={() => setSections([...sections, { id: Date.now().toString(), title: 'New Section', content: '' }])}
         />

         {/* CENTER: EDITOR CANVAS */}
         <div className="flex-1 bg-slate-100 overflow-y-auto p-4 md:p-8 flex justify-center">
             <div className="w-full max-w-3xl bg-white rounded-xl shadow-sm min-h-[800px] p-8 md:p-12 relative group animate-in fade-in slide-in-from-bottom-4 duration-500">
                
                {isGenerating && (
                    <div className="absolute inset-0 bg-white/80 backdrop-blur-sm z-20 flex flex-col items-center justify-center rounded-xl">
                        <Loader2 size={48} className="text-indigo-600 animate-spin mb-4" />
                        <h3 className="text-xl font-bold text-slate-900">Generating {doc.type}...</h3>
                        <p className="text-slate-500">Consulting Gemini 3...</p>
                    </div>
                )}

                {sections.map((section) => (
                    <div 
                        key={section.id} 
                        className={`mb-12 group/section transition-opacity ${activeSectionId !== section.id ? 'opacity-50 hover:opacity-100' : 'opacity-100'}`}
                        onClick={() => setActiveSectionId(section.id)}
                    >
                        <input 
                            value={section.title}
                            onChange={(e) => updateSectionTitle(section.id, e.target.value)}
                            className="text-2xl font-bold text-slate-900 mb-4 outline-none border-b border-transparent hover:border-slate-200 pb-1 w-full" 
                        />
                        
                        <div 
                            className="prose prose-slate max-w-none text-lg text-slate-600 outline-none p-2 rounded hover:bg-slate-50/50 focus:bg-white"
                            contentEditable
                            suppressContentEditableWarning
                            onBlur={(e) => updateSectionContent(section.id, e.currentTarget.innerHTML)}
                            dangerouslySetInnerHTML={{ __html: section.content }}
                        />
                    </div>
                ))}
                
                {sections.length === 0 && (
                    <div className="text-center py-20 text-slate-400">
                        <Sparkles size={48} className="mx-auto mb-4 opacity-50" />
                        <p>No content yet. Use the AI Companion to generate a draft.</p>
                    </div>
                )}

             </div>
         </div>

         <EditorSidebar 
            activeSectionTitle={sections.find(s => s.id === activeSectionId)?.title || "None"}
            docType={doc.type}
            profile={profile}
            isGenerating={isGenerating}
            refiningAction={refiningAction}
            onGenerateDraft={handleGenerateDraft}
            onRefine={handleRefine}
         />
      </div>
    </MotionDiv>
  );
};
